
# 操作系统管理内存

> 操作系统需要管理物理内存和线性地址空间。

* `!process 0 0` 查看进程
* `dt _eprocess 82014220` 查看进程对象结构

* 在进程对象中可以看到 `+0x160 PhysicalVadList  : _LIST_ENTRY [ 0x82014380 - 0x82014380 ]` 物理地址链表结构，这个链表结构中保存了进程的物理内存地址。
* `!vad 82014380` 查看链表结构
* `+0x11c VadRoot          : 0x81d34e80 Void` 树结构 线性地址分配情况
* `!vad 0x81d34e80` 查看线性地址分配情况

查找页目录表基地址
```
0: kd> dt _KPROCESS 82014220
nt!_KPROCESS
   +0x000 Header           : _DISPATCHER_HEADER
   +0x010 ProfileListHead  : _LIST_ENTRY [ 0x82014230 - 0x82014230 ]
   +0x018 DirectoryTableBase : [2] 0x2b402c0
```

# Windows操作系统

* 作者相关书籍
* WRK Windows Research Kernel ==> ntoskrnl.exe
* ReactOS
* 下载 `source insight` 软件方便查看源码

* `dg 30` 查看KPCR的首地址

* _KPCR 内核处理器控制块 利用fs:[0]寄存器存储
``` C++
0: kd> dt _kpcr
nt!_KPCR
   +0x000 NtTib            : _NT_TIB
   +0x01c SelfPcr          : Ptr32 _KPCR
   +0x020 Prcb             : Ptr32 _KPRCB
   +0x024 Irql             : UChar
   +0x028 IRR              : Uint4B
   +0x02c IrrActive        : Uint4B
   +0x030 IDR              : Uint4B
   +0x034 KdVersionBlock   : Ptr32 Void
   +0x038 IDT              : Ptr32 _KIDTENTRY
   +0x03c GDT              : Ptr32 _KGDTENTRY
   +0x040 TSS              : Ptr32 _KTSS
   +0x044 MajorVersion     : Uint2B
   +0x046 MinorVersion     : Uint2B
   +0x048 SetMember        : Uint4B
   +0x04c StallScaleFactor : Uint4B
   +0x050 DebugActive      : UChar
   +0x051 Number           : UChar
   +0x052 Spare0           : UChar
   +0x053 SecondLevelCacheAssociativity : UChar
   +0x054 VdmAlert         : Uint4B
   +0x058 KernelReserved   : [14] Uint4B
   +0x090 SecondLevelCacheSize : Uint4B
   +0x094 HalReserved      : [16] Uint4B
   +0x0d4 InterruptMode    : Uint4B
   +0x0d8 Spare1           : UChar
   +0x0dc KernelReserved2  : [17] Uint4B
   +0x120 PrcbData         : _KPRCB

0: kd> dt _KPRCB
nt!_KPRCB
   +0x000 MinorVersion     : Uint2B
   +0x002 MajorVersion     : Uint2B
   +0x004 CurrentThread    : Ptr32 _KTHREAD
   +0x008 NextThread       : Ptr32 _KTHREAD
   +0x00c IdleThread       : Ptr32 _KTHREAD

0: kd> dt _KTHREAD
nt!_KTHREAD
   +0x000 Header           : _DISPATCHER_HEADER
   +0x010 MutantListHead   : _LIST_ENTRY
   +0x018 InitialStack     : Ptr32 Void
   +0x01c StackLimit       : Ptr32 Void
   +0x020 Teb              : Ptr32 Void
   +0x024 TlsArray         : Ptr32 Void
   +0x028 KernelStack      : Ptr32 Void
   +0x02c DebugActive      : UChar
   +0x02d State            : UChar
   +0x02e Alerted          : [2] UChar
   +0x030 Iopl             : UChar
   +0x031 NpxState         : UChar
   +0x032 Saturation       : Char
   +0x033 Priority         : Char
   +0x034 ApcState         : _KAPC_STATE

0: kd> dt _KAPC_STATE
nt!_KAPC_STATE
   +0x000 ApcListHead      : [2] _LIST_ENTRY
   +0x010 Process          : Ptr32 _KPROCESS
   +0x014 KernelApcInProgress : UChar
   +0x015 KernelApcPending : UChar
   +0x016 UserApcPending   : UChar

0: kd> dt _eprocess
nt!_EPROCESS
   +0x000 Pcb              : _KPROCESS
0: kd> dt _KPROCESS
nt!_KPROCESS
   +0x000 Header           : _DISPATCHER_HEADER
   +0x010 ProfileListHead  : _LIST_ENTRY
   +0x018 DirectoryTableBase : [2] Uint4B // 页目录表基地址
   +0x06c ProcessLock      : _EX_PUSH_LOCK
   +0x070 CreateTime       : _LARGE_INTEGER
   +0x078 ExitTime         : _LARGE_INTEGER
   +0x080 RundownProtect   : _EX_RUNDOWN_REF
   +0x084 UniqueProcessId  : Ptr32 Void // ProcessId
   +0x088 ActiveProcessLinks : _LIST_ENTRY // 进程链表
   +0x174 ImageFileName    : [16] UChar // 进程名
```

* `u PsGetCurrentProcess` 获取当前进程EPROCESS结构体
``` C++
0: kd> u PsGetCurrentProcess
nt!IoGetCurrentProcess:
8052c2d2 64a124010000    mov     eax,dword ptr fs:[00000124h]
8052c2d8 8b4044          mov     eax,dword ptr [eax+44h]
8052c2db c3              ret
```

**暴力读取内存**
``` C++
#include <Ntifs.h>
#include <ntddk.h>

//系统版本兼容文件
VOID Unload(_In_ struct _DRIVER_OBJECT* DriverObject) {
    UNREFERENCED_PARAMETER(DriverObject);
    DbgPrint("[51asm] Unload\n");
}

//int GetOffset(int nType) {
//    PsGetVersion();
//    if (nType == IAMGENAME_OFFSET) {
//        switch () {
//        case 7603:
//            break;
//        }
//    }
//}

PVOID MyGetDirBaseByPid(HANDLE ProcessId) {
    PEPROCESS Process = NULL;
    PEPROCESS Head = NULL;
    HANDLE UniqueProcessId = NULL;
    UCHAR* ImageFileName = NULL;
    PVOID  DirectoryTableBase = NULL;
    PVOID  DirBase = NULL;

    PAGED_CODE();

    __try {
        __asm {
            mov eax, fs: [124h] ;//ETHREAD
            mov eax, [eax + 44h];//EPROCESS
            mov Process, eax
        }

        Head = Process;
        do {
            if (Process == NULL || !MmIsAddressValid(Process)) {
                break;
            }
            UniqueProcessId = *(HANDLE*)((char*)Process + 0x84);
            ImageFileName = (UCHAR*)Process + 0x174;
            DirectoryTableBase = *(PVOID*)((char*)Process + 0x18);
            DbgPrint("[51asm] Process:%p UniqueProcessId:%p ImageFileName:%s DirectoryTableBase:%p\n", 
                Process, UniqueProcessId, ImageFileName, DirectoryTableBase);

            if (UniqueProcessId == ProcessId) {
                DirBase = DirectoryTableBase;
                break;
            }
            Process = *(void**)((char*)Process + 0x88);
            Process = (PEPROCESS)((char*)Process - 0x88);
        } 
        while (Process != Head);
    }
    __except (1) {
        DbgPrint("[51asm] EnumProcess __except\n");
    }

    return DirBase;
}

NTSTATUS MyReadProcessMemory(HANDLE hProcess,     
    PVOID lpBaseAddress,
    PVOID lpBuffer,       
    SIZE_T nSize) {

    DbgPrint("[51asm] MyReadProcessMemory hProcess:%p lpBaseAddress:%p lpBuffer:%p nSize:%08x\n", 
        hProcess, lpBaseAddress, lpBuffer, nSize);
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PVOID DirBase = MyGetDirBaseByPid(hProcess);
    PVOID OldDirBase = NULL;
    DbgPrint("[51asm] MyReadProcessMemory DirBase:%p\n", DirBase);
    if (DirBase == NULL)
        return Status;

    __try {
        __asm {
            mov eax, cr3
            mov OldDirBase, eax
            mov eax, DirBase
            mov cr3, eax
            // cli
        }

        if (MmIsAddressValid(lpBaseAddress)) {
            RtlCopyMemory(lpBuffer, lpBaseAddress, nSize);
        }   
    }
    finally {
        DbgPrint("[51asm] MyReadProcessMemory finally\n");
        __asm {
           // sti
            mov eax, OldDirBase
            mov cr3, eax
        }
    }
    return Status;
}

NTSTATUS MyWriteProcessMemory(HANDLE hProcess,
    PVOID lpBaseAddress,
    PVOID lpBuffer,
    SIZE_T nSize) {

    DbgPrint("[51asm] MyWriteProcessMemory hProcess:%p lpBaseAddress:%p lpBuffer:%p nSize:%08x\n",
        hProcess, lpBaseAddress, lpBuffer, nSize);
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    KdBreakPoint(); // 触发中断异常

    PVOID DirBase = MyGetDirBaseByPid(hProcess);
    PVOID OldDirBase = NULL;
    DbgPrint("[51asm] MyWriteProcessMemory DirBase:%p\n", DirBase);
    if (DirBase == NULL)
        return Status;

    __try {
        __asm {
            cli   // 提高当前核心当前线程优先级
            /*
            如果提高当前线程当前核心优先级，系统将无法中断，这样会导致出现缺页异常时，系统无法换页，从而导致读取不成功
            如果降低自己的优先级，则在读取时系统会中断，不会缺页，从而读取成功
            这里我们要修改内存但是没有权限，所以修改写保护位，并且提升优先级，防止切换到其他线程，出现问题
            */
            mov eax, cr3
            mov OldDirBase, eax
            mov eax, DirBase
            mov cr3, eax
            //关闭写保护
            mov eax, cr0
            and eax, not 10000h
            mov cr0, eax
        }

        if (MmIsAddressValid(lpBaseAddress)) {
            RtlCopyMemory(lpBaseAddress, lpBuffer, nSize);
            Status = STATUS_SUCCESS;
        }

        __asm {
            mov eax, cr0
            or eax, 10000h
            mov cr0, eax
            mov eax, OldDirBase
            mov cr3, eax
            sti
        }
    }
    __except(1) {
        DbgPrint("[51asm] MyWriteProcessMemory __except\n");
        __asm {
            mov eax, cr0
            or eax, 10000h
            mov cr0, eax
            mov eax, OldDirBase
            mov cr3, eax
            sti
        }
    }
    return Status;
}

NTSTATUS DriverEntry(
    __in struct _DRIVER_OBJECT* DriverObject,
    __in PUNICODE_STRING  RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    DbgPrint("[51asm] DriverEntry\n");

    DriverObject->DriverUnload = Unload;

   /* unsigned char Buffer[2] = { 0 };
    NTSTATUS Status = MyReadProcessMemory((HANDLE)1372, (PVOID)0x00410070, Buffer, sizeof(Buffer));
    DbgPrint("[51asm] DriverEntry MyReadProcessMemory Status:%08x Buffer:%02X %02X\n", Status, Buffer[0], Buffer[1]);
    */
    unsigned char Buffer[2] = { 0xc3, 0xc2 };
    NTSTATUS Status = MyWriteProcessMemory((HANDLE)1372, (PVOID)0x00410070, Buffer, sizeof(Buffer));
    DbgPrint("[51asm] DriverEntry MyWriteProcessMemory Status:%08x Buffer:%02X %02X\n", Status, Buffer[0], Buffer[1]);

    return STATUS_SUCCESS;
}
```
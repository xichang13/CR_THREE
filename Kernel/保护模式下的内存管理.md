
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [保护模式下的内存管理](#保护模式下的内存管理)
  - [分段管理](#分段管理)

<!-- /code_chunk_output -->


# 保护模式下的内存管理

> CPU可以对所有物理内存进行操作，但是无法区分内存属性，所以需要由系统来进行内存管理，系统告诉CPU内存的属性，所以需要有一套内存管理机制，让CPU和系统通讯。

![Segmentation and Paging](pic/保护模式下的内存管理/image.png)

## 分段管理

> 在16位中，分段是为了访问地址，在32位中，分段是为了保护内存，区分内存属性。
> 分段可以为每个程序或者任务提供单独的代码、数据和栈模块，保证进程隔离。

* 可以通过段基址加偏移(进程的虚拟地址)的方式访问真实的内存。

![Logical Address to Linear Address Translation](pic/保护模式下的内存管理/image-1.png)

* 其中32位的Offset是进程的虚拟地址(0X00401000)。
* 16位是段选择器(Segmentation Selector)，其中高13位是段描述符表索引，第3位0表示全局描述符表，1表示局部描述符表，低2位是RPL(请求特权级)。

![Segment Selector](pic/保护模式下的内存管理/image-2.png)

* 全局描述符表(Global Descriptor Table) 所有进程共享，通过GDTR寄存器来访问。
* 局部描述符表(Local Descriptor Table)  每个进程独有，通过LDTR寄存器来访问。

![Global and Local Descriptor Tables](pic/保护模式下的内存管理/image-3.png)

* 寄存器中包含了段描述符表基地址(Base Address)和界限(Limit)。
    * Base Address: 32位
    * Limit: 16位
* `SGDT m`: 获取GDTR寄存器的值。
* `SLDT m`: 获取LDTR寄存器的值。
* `LGDT m`: 设置GDTR寄存器的值。
* `LLDT m`: 设置LDTR寄存器的值。

![Pseudo-Descriptor Format](pic/保护模式下的内存管理/image-4.png)

* 段描述符表为64位

![Segment Descriptor](pic/保护模式下的内存管理/image-5.png)

``` C++
struct SegmentDescriptors {
	unsigned long long  limit:16;	//段界限
	unsigned long long  base:24;	//段基址
	unsigned long long  type:4;		//段类型
	unsigned long long  s:1;		//描述符类型 0=系统段 1=存储段
	unsigned long long  dpl:2;		//描述符特权级 ring0~ring3  r  r/w  r/e
	unsigned long long  p:1;		//存在位, 删除标志, 0=释放 1=存在
	unsigned long long  limitHei:4;	//段界限
	unsigned long long  avl:1;		//软件可利用位, 可用作操作系统扩展
	unsigned long long  res:1;		//保留位
	unsigned long long  db:1;		//0 16位段  1 32位段	
	unsigned long long  g:1;		//粒度位 0=byte=limit*1  1=4K=limit*4K+0xfff 
	unsigned long long  baseHei:8;  //段基址
};
```

* `type`字段 段类型

![Code- and Data-Segment Types](pic/保护模式下的内存管理/image-6.png)
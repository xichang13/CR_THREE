
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [类](#类)
  - [局部对象](#局部对象)
  - [全局对象](#全局对象)
  - [堆对象](#堆对象)
    - [堆对象数组](#堆对象数组)
  - [静态对象](#静态对象)
  - [参数对象和返回对象](#参数对象和返回对象)

<!-- /code_chunk_output -->


# 类

## 局部对象

**识别构造函数的特征：**
1. 调用约定 __thiscall
  * 参数1 ecx(this)
  * 参数2 入栈
  * ...
2. 作用域内第一个被调用的函数
3. 返回值是this指针

**识别析构函数的特征：**
1. 调用约定 __thiscall
  * 参数1 ecx(this)
2. 作用域内最后一个被调用的函数
3. 没有返回值
4. 析构代码函数，通过参数决定是否释放内存

**析构代理**
* 析构代理有传入一个标志参数
  * 0：显示调用析构
  * 1：delete调用析构
  * 2：delete[]调用析构

## 全局对象

* 对象的数据在全局数据区
* 构造函数在main函数之前调用，注册__initterm()函数调用
* 析构函数在main之后，程序结束之前，在构造函数之后注册atexit(destructor_proxy)函数调用

## 堆对象

* 在调用构造函数之前申请内存，返回值是this指针
* 析构时先析构，再释放内存

### 堆对象数组

在32位程序中，编译器使用堆空间的前4个字节保存对象的总个数。并且会有专门的构造迭代器和析构迭代器。
``` masm
0041229F                 push    offset sub_411127 ; void (__thiscall *)(void *) ; 析构函数
004122A4                 push    offset sub_4114B0 ; void (__thiscall *)(void *) ; 构造函数
004122A9                 push    0Ah             ; unsigned int ; 数组个数
004122AB                 push    8               ; unsigned int ; 对象大小
004122AD                 lea     eax, [ebp+var_58]              
004122B0                 push    eax             ; void *       ; 数组首地址
004122B1                 call    j_??_L@YGXPAXIIP6EX0@Z1@Z ; `eh vector constructor iterator'(void *,uint,uint,void (*)(void *),void (*)(void *))
004122B6                 mov     [ebp+var_124], 0
004122C0                 push    offset sub_411127 ; void (__thiscall *)(void *) ; 析构函数
004122C5                 push    0Ah             ; unsigned int ; 数组个数
004122C7                 push    8               ; unsigned int ; 对象大小
004122C9                 lea     eax, [ebp+var_58]
004122CC                 push    eax             ; void *       ; 数组首地址
004122CD                 call    j_??_M@YGXPAXIIP6EX0@Z@Z ; `eh vector destructor iterator'(void *,uint,uint,void (*)(void *))
```

* eh vector constructor iterator
  1. 数组首地址
  2. 类大小
  3. 元素数量
  4. 构造函数的地址
  5. 析构函数的地址
* eh vector destructor iterator
  1. 数组首地址
  2. 类大小
  3. 元素数量
  4. 析构函数的地址

## 静态对象

* 先判断标志，再调用构造函数，数据在全局数据区
* 使用atexit(destructor_proxy)函数调用析构函数

## 参数对象和返回对象

* **参数对象**
  1. 函数外构造
  2. 函数内析构
* **返回对象**
  1. 函数内构造
  2. 函数外析构

**无名对象**
``` C++
Point ShowPoint(){
  return Point(1,2);
}
int main(){
  Point pt = ShowPoint();
}
```
* 直接使用1,2构造返回对象，没有局部对象

**临时对象**
``` C++
Point ShowPoint(){
  Point pt(1,2);
  return pt;
}
int main(){
  Point pt = ShowPoint();
}
```
* 先构造局部对象，再构造返回对象，最后析构局部对象

**引用对象**
``` C++
void ShowPoint(const Point &pt){
  printf("%d %d\n",pt.x,pt.y);
}
int main(){
  ShowPoint(Point(1,2));
  ShowPoint(1);
}
```
* 直接使用1,2构造返回对象，没有局部对象
* 1在外部构造对象，在外部析构，作用域在main函数

## 虚函数

使用 virtual 关键字声明函数为虚函数，编译器会将该类所有虚函数地址保存在一张虚表中，同时会在类对象首地址处保存虚表地址。

* 虚表地址在构造函数中初始化
* 虚函数在调用时，通过虚表地址找到虚函数地址，再调用虚函数
* 在析构时也会填虚表指针，所以我们可以通过填充虚表指针确定是否为构造函数或析构函数

只有在使用对象的指针或引用调用虚函数，才会使用虚表间接调用虚函数，否则对象会直接调用虚函数。